<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Tokamak Multi-Espèces - Boris NR & Coulomb</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #00ffaa; font-family: 'Courier New', Courier, monospace; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0, 10, 20, 0.9); padding: 15px; border: 1px solid #00ffaa; border-radius: 5px; pointer-events: none; }
        .label { color: #888; font-size: 0.8rem; }
        .val { color: #fff; font-weight: bold; }
        .species { display: flex; gap: 10px; margin-top: 5px; }
        .proton { color: #00aaff; }
        .electron { color: #ffaa00; }
    </style>
</head>
<body>
    <div id="ui">
        <b>TOKAMAK MULTI-ESPÈCES</b><br>
        <span class="label">Champ :</span> <span class="val">Hélicoïdal (Tor + Pol)</span><br>
        <div class="species">
            <span class="proton">● Protons (+1)</span>
            <span class="electron">● Électrons (-1)</span>
        </div>
        <span class="label">Interaction :</span> <span class="val">Coulomb O(N²)</span><br>
        <span class="label">FPS :</span> <span id="fps" class="val">0</span>
    </div>
    <canvas id="canvas"></canvas>

    <script type="module">
        const PARTICLE_COUNT = 16384; 
        const R_MAJOR = 42.0;
        const R_MINOR = 16.0;

        const computeShaderCode = `
            struct Particle { 
                pos : vec4<f32>, // x, y, z, w: charge
                vel : vec4<f32>  // vx, vy, vz, w: mass
            };
            struct Params { dt : f32, time : f32, rMaj : f32, rMin : f32, qm_base : f32, coulomb : f32 };

            @group(0) @binding(0) var<storage, read_write> particles : array<Particle>;
            @group(0) @binding(1) var<uniform> params : Params;
            
            var<workgroup> shared_pos : array<vec4<f32>, 64>;

            @compute @workgroup_size(64)
            fn main(@builtin(global_invocation_id) gId : vec3<u32>, @builtin(local_invocation_id) lId : vec3<u32>) {
                let idx = gId.x;
                let num_particles = arrayLength(&particles);
                
                var p : Particle;
                if (idx < num_particles) { p = particles[idx]; }

                // --- 1. FORCE DE COULOMB (CHAMP E) ---
                var E = vec3<f32>(0.0);
                for (var i = 0u; i < num_particles; i += 64u) {
                    // On charge la position ET la charge (pos.w)
                    shared_pos[lId.x] = particles[i + lId.x].pos;
                    workgroupBarrier();

                    if (idx < num_particles) {
                        for (var j = 0u; j < 64u; j++) {
                            let other = shared_pos[j];
                            let r_vec = p.pos.xyz - other.xyz;
                            let dist_sq = dot(r_vec, r_vec) + 0.01; 
                            
                            if (i + j != idx) { 
                                // F = (q1 * q2) / r^2
                                // La force appliquée dépend du signe de la charge locale p.pos.w
                                let q1q2 = p.pos.w * other.w;
                                E += normalize(r_vec) * (params.coulomb * q1q2 / dist_sq); 
                            }
                        }
                    }
                    workgroupBarrier();
                }

                if (idx < num_particles) {
                    // --- 2. CHAMP MAGNÉTIQUE HÉLICOÏDAL (B) ---
                    let R_curr = length(p.pos.xz);
                    let tor_dir = normalize(vec3<f32>(-p.pos.z, 0.0, p.pos.x));
                    let B_tor = tor_dir * (100.0 / (R_curr + 0.1));

                    let center_pt = normalize(vec3<f32>(p.pos.x, 0.0, p.pos.z)) * params.rMaj;
                    let r_vec_pol = p.pos.xyz - center_pt;
                    let pol_dir = normalize(cross(r_vec_pol, tor_dir));
                    let B_pol = pol_dir * 18.0; 
                    
                    let B_total = B_tor + B_pol;

                    // --- 3. INTÉGRATEUR DE BORIS ---
                    let dt = params.dt;
                    // q/m effectif (p.pos.w = charge, p.vel.w = masse)
                    let qm = (p.pos.w / p.vel.w) * params.qm_base;
                    let qm_half_dt = qm * dt * 0.5;

                    let v_minus = p.vel.xyz + E * qm_half_dt;

                    // Rotation de Boris
                    let t = B_total * qm_half_dt;
                    let s = (2.0 * t) / (1.0 + dot(t, t));
                    let v_prime = v_minus + cross(v_minus, t);
                    let v_plus = v_minus + cross(v_prime, s);

                    p.vel = vec4<f32>((v_plus + E * qm_half_dt) * 0.999, p.vel.w);
                    p.pos = vec4<f32>(p.pos.xyz + p.vel.xyz * dt, p.pos.w);

                    // --- 4. CONFINEMENT PHYSIQUE ---
                    if (distance(p.pos.xyz, center_pt) > params.rMin) {
                        let n = normalize(p.pos.xyz - center_pt);
                        p.pos = vec4<f32>(center_pt + n * params.rMin, p.pos.w);
                        p.vel = vec4<f32>(reflect(p.vel.xyz, -n) * 0.3, p.vel.w);
                    }

                    particles[idx] = p;
                }
            }
        `;

        const renderShaderCode = `
            struct Particle { pos : vec4<f32>, vel : vec4<f32> };
            @group(0) @binding(0) var<storage, read> particles : array<Particle>;
            @group(0) @binding(1) var<uniform> mvp : mat4x4<f32>;
            struct Out { @builtin(position) pos : vec4<f32>, @location(0) color : vec4<f32> };

            @vertex
            fn vs_main(@builtin(vertex_index) idx : u32) -> Out {
                var o : Out;
                let p = particles[idx];
                o.pos = mvp * vec4<f32>(p.pos.xyz, 1.0);
                
                // Coloration par charge : Bleu = Proton (+1), Orange/Rouge = Électron (-1)
                if (p.pos.w > 0.0) {
                    o.color = vec4<f32>(0.0, 0.6, 1.0, 1.0);
                } else {
                    o.color = vec4<f32>(1.0, 0.4, 0.0, 1.0);
                }
                return o;
            }

            @fragment
            fn fs_main(@location(0) color : vec4<f32>) -> @location(0) vec4<f32> { return color; }
        `;

        async function init() {
            if (!navigator.gpu) return alert("WebGPU requis");
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            const ctx = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            ctx.configure({ device, format });

            const data = new Float32Array(PARTICLE_COUNT * 8);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const a = Math.random() * Math.PI * 2;
                const r = Math.random() * R_MINOR;
                
                // Position
                data[i*8] = Math.cos(a) * (R_MAJOR + r);
                data[i*8+1] = (Math.random() - 0.5) * 6.0;
                data[i*8+2] = Math.sin(a) * (R_MAJOR + r);
                
                // Charge (pos.w) : 50% +1, 50% -1
                const isProton = i < PARTICLE_COUNT / 2;
                data[i*8+3] = isProton ? 1.0 : -1.0;
                
                // Vitesse initiale
                data[i*8+4] = (Math.random() - 0.5) * 4.0;
                data[i*8+5] = (Math.random() - 0.5) * 4.0;
                data[i*8+6] = (Math.random() - 0.5) * 4.0;
                
                // Masse (vel.w) : Protons plus lourds (1.0), Électrons légers (0.05)
                data[i*8+7] = isProton ? 1.0 : 0.05;
            }

            const pBuffer = device.createBuffer({ size: data.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
            device.queue.writeBuffer(pBuffer, 0, data);
            const simBuffer = device.createBuffer({ size: 32, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            const mBuffer = device.createBuffer({ size: 64, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            const cPipe = device.createComputePipeline({ layout: 'auto', compute: { module: device.createShaderModule({ code: computeShaderCode }), entryPoint: 'main' } });
            const rPipe = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: device.createShaderModule({ code: renderShaderCode }), entryPoint: 'vs_main' },
                fragment: { module: device.createShaderModule({ code: renderShaderCode }), entryPoint: 'fs_main', targets: [{ format }] },
                primitive: { topology: 'point-list' }
            });

            const cBind = device.createBindGroup({ layout: cPipe.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: pBuffer } }, { binding: 1, resource: { buffer: simBuffer } }] });
            const rBind = device.createBindGroup({ layout: rPipe.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: pBuffer } }, { binding: 1, resource: { buffer: mBuffer } }] });

            let lastTime = performance.now();
            function frame() {
                const now = performance.now();
                document.getElementById('fps').innerText = Math.round(1000/(now-lastTime));
                lastTime = now;
                const t = now * 0.001;
                
                // dt, time, Rmaj, Rmin, qm_base, coulomb_strength
                device.queue.writeBuffer(simBuffer, 0, new Float32Array([0.016, t, R_MAJOR, R_MINOR, 10.0, 5.0]));
                
                const mvp = getMVP(canvas.width, canvas.height, [Math.cos(t*0.15)*130, 80, Math.sin(t*0.15)*130]);
                device.queue.writeBuffer(mBuffer, 0, mvp);

                const enc = device.createCommandEncoder();
                const cp = enc.beginComputePass();
                cp.setPipeline(cPipe); cp.setBindGroup(0, cBind);
                cp.dispatchWorkgroups(PARTICLE_COUNT / 64);
                cp.end();

                const rp = enc.beginRenderPass({ colorAttachments: [{ view: ctx.getCurrentTexture().createView(), loadOp: 'clear', clearValue: {r:0,g:0.02,b:0.04,a:1}, storeOp: 'store' }] });
                rp.setPipeline(rPipe); rp.setBindGroup(0, rBind);
                rp.draw(PARTICLE_COUNT);
                rp.end();

                device.queue.submit([enc.finish()]);
                requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);
        }

        // --- MATH UTILS ---
        function getMVP(w, h, eye) {
            const aspect = w / h;
            const p = new Float32Array(16);
            const f = 1.0 / Math.tan(30 * Math.PI / 180);
            p[0] = f/aspect; p[5] = f; p[10] = -1.002; p[11] = -1; p[14] = -2.002;
            const target = [0, 0, 0]; const up = [0, 1, 0];
            const z = normalize([eye[0]-target[0], eye[1]-target[1], eye[2]-target[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            const v = new Float32Array([x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -dot(x,eye), -dot(y,eye), -dot(z,eye), 1]);
            const out = new Float32Array(16);
            for(let i=0; i<4; i++) for(let j=0; j<4; j++) {
                let s = 0; for(let k=0; k<4; k++) s += p[k*4+i] * v[j*4+k];
                out[j*4+i] = s;
            }
            return out;
        }
        function normalize(v) { const l = Math.sqrt(v[0]**2+v[1]**2+v[2]**2); return [v[0]/l, v[1]/l, v[2]/l]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function dot(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }

        init();
    </script>
</body>
</html>